---
layout: post
title:  "Clojure Macros Tutorial - part 4: Examples of cool macros #cljklipse @viebel"
description:  "macros tutorial examples Clojure clojurescript defprint doseq doseq-indexed disp"
date:   2016-05-09 17:12:43 +0200
categories: clojure
thumbnail: assets/klipse.png
guid: "E4991207-5FDC-43BF-830F-C50D5CDB4B5C"
author: "@viebel"

---

This article is the last part of our Clojure macros tutorial. The previous parts were:

1. [functions vs. macros]({% post_url 2016-05-01-macro-tutorial-1 %}) 
2. [how not to write macros]({% post_url 2016-05-04-macro-tutorial-2 %})
3. [syntax quote]({% post_url 2016-05-05-macro-tutorial-3 %})

Now we are going to show you how `clojure` ninjas write macros.

![Ninja](/assets/ninja.jpg)

### The `disp` macro - by 2 anonymous ninjas

The `disp` macro receives expressions and returns a string with the expressions and their respective evaluations.

~~~klipse

(ns my.best$macros)

(defmacro disp [& forms]
  (cons `str (for [form forms]
                 `(str (pr-str '~form) " => " (pr-str ~form) "\n"))))

(my.best/disp 
  (map inc [1 2 3])
    (+ 4 5 6))

~~~

Two smart guys on [Clojurians Slack](https://clojurians.slack.com) helped me to write the `disp` macros.

### The `defprint` macro - by Herwig Hochleitner 

The `defprint` macro defines a function with a tweak: each time the function is called, it prints the values of its arguments. The tricky part is that it works also with desctructuring.

~~~klipse
(ns my.best$macros)

(defmacro defprint [func-name args & body]
  `(defn ~func-name [& args#]
       (print '~func-name "called with: " args#)
            (let [~args args#]
                   ~@body)))

(my.best/defprint foo [a b c] (+ a b c))
(foo 1 2 3)
~~~


And here is what is printed in when `foo` is called:

~~~klipse
(with-out-str (foo 1 2 3))
~~~

Another example, with arguments desctructuring:

~~~klipse
(my.best/defprint hello-world [& {:keys [language] 
                                  :or {language :en}}]
                                     (case language
                                                        :fr "bonjour monde"
                                                                           :en "hello world"))

(hello-world :language :fr)
~~~

~~~klipse
(with-out-str (hello-world :language :fr))
~~~

And here is the code generated by the macro:

~~~klipse
(macroexpand-1 '(my.best/defprint foo [& {:keys [language]} :or {language :en}]))

~~~

Take a couple of minutes to meditate on the power of this part of the macro:

~~~clojure
(let [~args args#]
       ~@body)
~~~

[Herwig Hochleitner](https://twitter.com/bendlas) helped me to write the `defprint` macro.

You can read [more about desctructuring]({% post_url 2016-03-31-destructuring-part-2 %}).

### The `doseq-indexed` macro - by Tim Baldridge

`doseq-indexed` works like `doseq` with an additional binding to the index. 

[Tim Baldridge](https://twitter.com/timbaldridge) (`core.async` author) wrote an elegant implementation for `doseq-indexed`:

~~~klipse
(ns my.best$macros)

(defmacro doseq-indexed [index-sym [item-sym coll] & body]
  `(doseq [[~item-sym ~index-sym]
             (map vector ~coll (range))]
                  ~@body))

(with-out-str
  (my.best/doseq-indexed i [x [10 100 1000]]
                           (println "i: " i "x: " x)))
~~~

Here is [Tim's original gist](https://gist.github.com/halgari/4136116).

Feel free to share your favorite macros in the comments below.

Clojure rocks!

[app-url-static]: http://app.klipse.tech?blog=klipse&js_only=1
[app-url]: http://app.klipse.tech?blog=klipse&static-fns=true&js_only=1

